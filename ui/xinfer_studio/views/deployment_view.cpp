#include "deployment_view.h"
#include "./ui_deployment_view.h" // Generated by CMake/uic from the .ui file

#include <QFileDialog>
#include <QMessageBox>
#include <QDateTime>
#include <QFileInfo>
#include <QDebug>

// Include standard platforms for the dropdown
// In a real app, this might come from a config file or introspection of available drivers
static const std::vector<std::pair<QString, QString>> STANDARD_PLATFORMS = {
    {"NVIDIA TensorRT", "nv-trt"},
    {"Intel OpenVINO", "intel-ov"},
    {"Rockchip RKNN", "rockchip-rknn"},
    {"AMD Vitis AI", "amd-vitis"},
    {"Qualcomm QNN", "qcom-qnn"},
    {"Apple CoreML", "apple-coreml"},
    {"Microchip VectorBlox", "microchip-vb"},
    {"Lattice sensAI", "lattice-sensai"},
    {"MediaTek NeuroPilot", "mediatek-np"}
};

DeploymentView::DeploymentView(QWidget *parent)
    : QWidget(parent), ui(new Ui::DeploymentView)
{
    ui->setupUi(this);

    // Initialize UI defaults
    populateTargets();
    ui->progressBar->setValue(0);
    ui->cmbPrecision->setCurrentIndex(0); // Default FP16

    // Setup the background worker thread
    setupThread();
}

DeploymentView::~DeploymentView() {
    // Graceful shutdown of the worker thread
    if (m_workerThread) {
        m_workerThread->quit();
        m_workerThread->wait();
    }
    delete ui;
}

void DeploymentView::setupThread() {
    m_workerThread = new QThread(this);
    m_controller = new CompilerController(); // No parent, will move to thread
    m_controller->moveToThread(m_workerThread);

    // Connect Controller Signals -> View Slots
    connect(m_controller, &CompilerController::logOutput, this, &DeploymentView::onLog);
    connect(m_controller, &CompilerController::progressChanged, this, &DeploymentView::onProgress);
    connect(m_controller, &CompilerController::compilationFinished, this, &DeploymentView::onFinished);

    // Cleanup controller when thread finishes
    connect(m_workerThread, &QThread::finished, m_controller, &QObject::deleteLater);

    m_workerThread->start();
}

void DeploymentView::setDeviceManager(xinfer::ui::core::DeviceManager* manager) {
    m_deviceManager = manager;
    // Optional: If you wanted to compile specifically for a registered device,
    // you could append user devices to the cmbTarget here.
    // For now, we stick to generic platforms.
}

void DeploymentView::populateTargets() {
    ui->cmbTarget->clear();
    for (const auto& pair : STANDARD_PLATFORMS) {
        // Display Name, UserData (internal ID)
        ui->cmbTarget->addItem(pair.first, pair.second);
    }
}

// =============================================================================
// UI Slots
// =============================================================================

void DeploymentView::on_btnBrowseInput_clicked() {
    QString filter = "Model Files (*.onnx *.tflite *.prototxt);;All Files (*)";
    QString path = QFileDialog::getOpenFileName(this, "Select Input Model", "", filter);

    if (!path.isEmpty()) {
        ui->lineEditInput->setText(path);

        // Auto-generate a suggested output path
        QFileInfo fi(path);
        QString currentTarget = ui->cmbTarget->currentData().toString();

        // Determine extension based on target (simple heuristic)
        QString ext = ".engine"; // Default NVIDIA
        if (currentTarget.contains("rknn")) ext = ".rknn";
        else if (currentTarget.contains("ov")) ext = ".xml";
        else if (currentTarget.contains("vitis")) ext = ".xmodel";
        else if (currentTarget.contains("qnn")) ext = ".bin";
        else if (currentTarget.contains("coreml")) ext = ".mlmodelc";

        QString suggestedOutput = fi.path() + "/" + fi.completeBaseName() + ext;
        ui->lineEditOutput->setText(suggestedOutput);
    }
}

void DeploymentView::on_btnBrowseOutput_clicked() {
    QString currentPath = ui->lineEditOutput->text();
    QString path = QFileDialog::getSaveFileName(this, "Save Compiled Model", currentPath);

    if (!path.isEmpty()) {
        ui->lineEditOutput->setText(path);
    }
}

void DeploymentView::on_btnCompile_clicked() {
    // 1. gather inputs
    QString inputPath = ui->lineEditInput->text();
    QString outputPath = ui->lineEditOutput->text();
    QString target = ui->cmbTarget->currentData().toString();
    QString precision = ui->cmbPrecision->currentText().toLower();

    // 2. Validation
    if (inputPath.isEmpty() || outputPath.isEmpty()) {
        QMessageBox::warning(this, "Missing Arguments", "Please specify both Input Model and Output Path.");
        return;
    }

    if (!QFileInfo::exists(inputPath)) {
        QMessageBox::critical(this, "File Error", "Input file does not exist:\n" + inputPath);
        return;
    }

    // 3. Prepare UI for processing
    ui->btnCompile->setEnabled(false);
    ui->progressBar->setValue(0);
    ui->txtLog->clear();

    onLog("--- Starting Compilation Job ---");
    onLog(QString("Target: %1").arg(target));
    onLog(QString("Precision: %1").arg(precision));
    onLog(QString("Input: %1").arg(inputPath));

    // 4. Prepare Parameters
    QVariantMap params;
    // Example: Check if we need calibration (INT8)
    if (precision == "int8") {
        // In a real app, we'd have a UI field for the calibration dataset path.
        // For now, we warn or set a default.
        onLog("WARNING: INT8 selected. Ensure calibration data is available to the driver.");
        // params["calibration_data"] = "/path/to/calib.txt";
    }

    // 5. Invoke Controller (Thread-Safe Call)
    QMetaObject::invokeMethod(m_controller, "compileModel",
                              Qt::QueuedConnection,
                              Q_ARG(QString, target),
                              Q_ARG(QString, inputPath),
                              Q_ARG(QString, outputPath),
                              Q_ARG(QString, precision),
                              Q_ARG(QVariantMap, params));
}

// =============================================================================
// Controller Updates
// =============================================================================

void DeploymentView::onLog(QString msg) {
    QString timestamp = QDateTime::currentDateTime().toString("HH:mm:ss");
    ui->txtLog->appendPlainText(QString("[%1] %2").arg(timestamp, msg));
}

void DeploymentView::onProgress(int percent) {
    ui->progressBar->setValue(percent);
}

void DeploymentView::onFinished(bool success, QString msg) {
    // Re-enable UI
    ui->btnCompile->setEnabled(true);

    if (success) {
        ui->progressBar->setValue(100);
        onLog("COMPILATION SUCCESS");
        QMessageBox::information(this, "Build Complete", msg);
    } else {
        ui->progressBar->setValue(0);
        onLog("COMPILATION FAILED: " + msg);
        QMessageBox::critical(this, "Build Error", msg);
    }
}