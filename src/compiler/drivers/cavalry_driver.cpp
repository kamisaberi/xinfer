#include <xinfer/compiler/drivers/cavalry_driver.h>
#include <xinfer/core/logging.h>

#include <iostream>
#include <sstream>
#include <filesystem>
#include <cstdlib>

namespace fs = std::filesystem;

namespace xinfer::compiler {

// Helper: safe quoting
static std::string quote(const std::string& path) {
    return "\"" + path + "\"";
}

bool AmbarellaDriver::validate_environment() {
    // 1. Check for Environment Variable
    const char* sdk_root = std::getenv("AMBA_CVFLOW_SDK");
    if (!sdk_root) {
        XINFER_LOG_ERROR("AMBA_CVFLOW_SDK environment variable not set.");
        return false;
    }

    // 2. Check for Compiler Binary
    fs::path compiler_path = fs::path(sdk_root) / "bin" / "cnngen";
    if (!fs::exists(compiler_path)) {
        XINFER_LOG_ERROR("Ambarella compiler 'cnngen' not found at: " + compiler_path.string());
        return false;
    }

    return true;
}

bool AmbarellaDriver::compile(const CompileConfig& config) {
    // Basic validation
    if (!fs::exists(config.input_path)) {
        XINFER_LOG_ERROR("Input ONNX model not found: " + config.input_path);
        return false;
    }

    const char* sdk_root = std::getenv("AMBA_CVFLOW_SDK");
    fs::path compiler_bin = fs::path(sdk_root) / "bin" / "cnngen";

    std::stringstream cmd;
    cmd << compiler_bin.string();

    // --- Input / Output ---
    // cnngen -m model.onnx -f onnx
    cmd << " -m " << quote(config.input_path);
    cmd << " -f onnx";

    // Output directory (Ambarella generates a folder structure)
    // We assume the user provided a directory path or file path.
    // cnngen uses -o for output directory.
    fs::path out_path(config.output_path);
    if (!out_path.has_extension()) {
        cmd << " -o " << quote(config.output_path);
    } else {
        // If user gave "model.cavalry", strip extension and use parent dir
        cmd << " -o " << quote(out_path.parent_path().string());
        cmd << " -n " << quote(out_path.stem().string()); // Name of the binary
    }

    // --- Precision / Quantization ---
    // Ambarella requires a quantization stats file for INT8.
    // If precision is INT8, we look for calibration data or explicit stats.
    if (config.precision == Precision::INT8) {
        if (!config.calibration_data_path.empty()) {
            // Assuming config.calibration_data_path points to the stats file generated by 'caffe_parser' or 'onnx_parser'
            cmd << " -s " << quote(config.calibration_data_path);
        } else {
            XINFER_LOG_WARN("INT8 requested but no Quantization Stats (-s) provided. Compiler may fail or use defaults.");
        }
    } else if (config.precision == Precision::FP16) {
        // CVFlow supports FP16 on newer chips (CV5/CV3)
        cmd << " --fp16_mode";
    }

    // --- Vendor Specific Params ---
    // Handle things like chip version (CV22, CV25, CV5)
    bool chip_set = false;
    for (const auto& param : config.vendor_params) {
        // Example: "CHIP=cv22"
        if (param.find("CHIP=") == 0) {
            cmd << " -v " << param.substr(5);
            chip_set = true;
        }
        // Example: "VAS_FLAGS=--auto-split"
        else if (param.find("VAS_FLAGS=") == 0) {
             cmd << " --vas_args=" << quote(param.substr(10));
        }
        // Raw flags
        else {
             cmd << " " << param;
        }
    }

    if (!chip_set) {
        XINFER_LOG_WARN("Target CHIP version not specified (e.g., CHIP=cv22). Defaulting to cv22.");
        cmd << " -v cv22";
    }

    // --- Execution ---
    XINFER_LOG_INFO("Executing Ambarella Compiler: " + cmd.str());

    int result = std::system(cmd.str().c_str());

    // Validation of output
    // cnngen usually produces a file named 'cavalry.bin' inside the output folder
    // or whatever was specified by -n
    if (result == 0) {
        XINFER_LOG_SUCCESS("Cavalry Binary generated successfully.");
        return true;
    } else {
        XINFER_LOG_ERROR("cnngen failed with return code: " + std::to_string(result));
        return false;
    }
}

} // namespace xinfer::compiler