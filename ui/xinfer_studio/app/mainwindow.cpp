#include "mainwindow.h"
#include "./ui_mainwindow.h" // Generated by CMake/uic

#include <QFileDialog>
#include <QMessageBox>
#include <QDateTime>
#include <QDebug>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // ---------------------------------------------------------
    // 1. Initialize Data Models
    // ---------------------------------------------------------
    // Load devices from JSON
    m_deviceManager = new xinfer::ui::core::DeviceManager("devices.json");
    m_deviceModel = new xinfer::ui::models::DeviceModel(m_deviceManager, this);

    // Bind to ComboBox
    ui->cmbTarget->setModel(m_deviceModel);
    ui->cmbTarget->setModelColumn(0); // Display Name

    // Select first item by default if available
    if (m_deviceModel->rowCount() > 0) {
        ui->cmbTarget->setCurrentIndex(0);
    }

    // ---------------------------------------------------------
    // 2. Initialize Worker Thread & Controller
    // ---------------------------------------------------------
    m_workerThread = new QThread(this);
    m_controller = new ZooController(); // Do NOT set parent yet, we move it
    m_controller->moveToThread(m_workerThread);

    // Connect Signals (Backend -> UI)
    // Use QueuedConnection to safely cross thread boundaries
    connect(m_controller, &ZooController::frameReady, this, &MainWindow::updateView, Qt::QueuedConnection);
    connect(m_controller, &ZooController::errorOccurred, this, &MainWindow::handleError, Qt::QueuedConnection);

    // We could add a log signal to ZooController if we want real-time backend logs
    // connect(m_controller, &ZooController::logMessage, this, &MainWindow::appendLog, Qt::QueuedConnection);

    // Start the thread event loop
    m_workerThread->start();

    // ---------------------------------------------------------
    // 3. UI Setup
    // ---------------------------------------------------------
    updateUIState(false);
    appendLog("System Ready.");
    appendLog("Loaded " + QString::number(m_deviceModel->rowCount()) + " devices.");
}

MainWindow::~MainWindow() {
    // Graceful Shutdown
    if (m_controller) {
        // Stop pipeline directly via meta-object system since it lives in another thread
        QMetaObject::invokeMethod(m_controller, "stopPipeline");
    }

    if (m_workerThread) {
        m_workerThread->quit();
        m_workerThread->wait();
    }

    delete m_controller; // Safe to delete after thread waits
    delete m_deviceManager;
    delete ui;
}

// =============================================================================
// UI Interaction Slots
// =============================================================================

void MainWindow::on_btnBrowse_clicked() {
    QString fileName = QFileDialog::getOpenFileName(this,
        tr("Open Model File"), "",
        tr("Model Files (*.engine *.rknn *.xmodel *.onnx *.xml);;All Files (*)"));

    if (!fileName.isEmpty()) {
        ui->lineEditModel->setText(fileName);
    }
}

void MainWindow::on_btnStart_clicked() {
    QString modelPath = ui->lineEditModel->text();
    int cameraId = ui->spinCameraId->value();

    // Get Selected Target from ComboBox
    int row = ui->cmbTarget->currentIndex();
    if (row < 0) {
        QMessageBox::warning(this, "Config Error", "Please select a target device.");
        return;
    }

    // Retrieve device info from model
    auto deviceInfo = m_deviceModel->getDevice(row);
    QString targetPlatform = deviceInfo.target; // e.g. "nv-trt"

    if (modelPath.isEmpty()) {
        QMessageBox::warning(this, "Config Error", "Please select a model file.");
        return;
    }

    appendLog(QString("Starting Inference..."));
    appendLog(QString("Target: %1 (%2)").arg(deviceInfo.name, targetPlatform));
    appendLog(QString("Model: %1").arg(modelPath));

    // Invoke 'startPipeline' on the worker thread
    // Params: string model_path, int camera_id
    // Note: We might need to extend startPipeline to accept 'targetPlatform' string
    // For now, assuming local execution or ZooController handles SSH tunneling logic internally.

    QMetaObject::invokeMethod(m_controller, "startPipeline",
                              Qt::QueuedConnection,
                              Q_ARG(std::string, modelPath.toStdString()),
                              Q_ARG(int, cameraId));

    updateUIState(true);
}

void MainWindow::on_btnStop_clicked() {
    appendLog("Stopping Inference...");

    QMetaObject::invokeMethod(m_controller, "stopPipeline", Qt::QueuedConnection);

    updateUIState(false);
}

void MainWindow::on_actionExit_triggered() {
    close();
}

void MainWindow::on_actionDevice_Manager_triggered() {
    // TODO: Open Device Manager Dialog
    // DeviceManagerDialog dlg(m_deviceManager, this);
    // dlg.exec();
    QMessageBox::information(this, "TODO", "Device Manager Dialog coming soon!");
}

// =============================================================================
// Data Slots
// =============================================================================

void MainWindow::updateView(const QImage& image) {
    if (!m_isPipelineRunning) return; // Ignore trailing frames

    // Pass frame to custom OpenGL widget
    ui->videoWidget->updateFrame(image);
}

void MainWindow::appendLog(QString message) {
    QString timestamp = QDateTime::currentDateTime().toString("HH:mm:ss");
    ui->txtLog->appendPlainText(QString("[%1] %2").arg(timestamp, message));
}

void MainWindow::handleError(QString message) {
    appendLog("ERROR: " + message);
    QMessageBox::critical(this, "xInfer Runtime Error", message);

    // Auto-stop on error
    updateUIState(false);
}

void MainWindow::updateUIState(bool running) {
    m_isPipelineRunning = running;

    ui->btnStart->setEnabled(!running);
    ui->btnStop->setEnabled(running);
    ui->groupBoxConfig->setEnabled(!running); // Lock config while running

    if (running) {
        ui->statusbar->showMessage("Status: Running Inference...");
    } else {
        ui->statusbar->showMessage("Status: Idle");
    }
}