#include <xinfer/zoo/cybersecurity/malware_classifier.h>
#include <xinfer/core/logging.h>
#include <xinfer/core/tensor.h>

// --- The Three Pillars ---
#include <xinfer/backends/backend_factory.h>
#include <xinfer/preproc/factory.h>
#include <xinfer/postproc/factory.h>
#include <xinfer/postproc/vision/classification_interface.h>

#include <iostream>
#include <cmath>
#include <vector>

namespace xinfer::zoo::cybersecurity {

// =================================================================================
// PImpl Implementation
// =================================================================================

struct MalwareClassifier::Impl {
    MalwareConfig config_;

    // Pipeline Components
    std::unique_ptr<backends::IBackend> engine_;
    std::unique_ptr<preproc::IImagePreprocessor> preproc_;
    std::unique_ptr<postproc::IClassificationPostprocessor> postproc_;

    // Data Containers
    core::Tensor input_tensor;
    core::Tensor output_tensor;

    Impl(const MalwareConfig& config) : config_(config) {
        initialize();
    }

    void initialize() {
        // 1. Load Backend
        engine_ = backends::BackendFactory::create(config_.target);

        xinfer::Config backend_cfg;
        backend_cfg.model_path = config_.model_path;
        backend_cfg.vendor_params = config_.vendor_params;

        if (!engine_->load_model(backend_cfg.model_path)) {
            throw std::runtime_error("MalwareClassifier: Failed to load model.");
        }

        // 2. Setup Preprocessor
        preproc_ = preproc::create_image_preprocessor(config_.target);

        preproc::ImagePreprocConfig pre_cfg;
        pre_cfg.target_width = config_.image_width;
        pre_cfg.target_height = config_.image_height;
        pre_cfg.target_format = preproc::ImageFormat::GRAY; // Input is a grayscale image
        pre_cfg.layout_nchw = true;

        // Standard 0-1 normalization for grayscale
        pre_cfg.norm_params.scale_factor = 1.0f / 255.0f;

        preproc_->init(pre_cfg);

        // 3. Setup Post-processor
        postproc_ = postproc::create_classification(config_.target);
        postproc::ClassificationConfig post_cfg;
        post_cfg.top_k = 1;
        post_cfg.apply_softmax = true;
        post_cfg.labels = config_.labels;
        postproc_->init(post_cfg);
    }

    // --- Core Logic: Binary to Image ---
    cv::Mat bytes_to_image(const std::vector<uint8_t>& bytes) {
        if (bytes.empty()) return cv::Mat();

        // 1. Determine Image Dimensions
        // Find the smallest square that fits the data.
        size_t size = bytes.size();
        int width = static_cast<int>(std::ceil(std::sqrt(static_cast<double>(size))));

        // 2. Create Image & Copy Data
        // Create a square matrix and copy the bytes, padding with zeros at the end.
        cv::Mat image = cv::Mat::zeros(width, width, CV_8UC1);

        std::memcpy(image.data, bytes.data(), size);

        return image;
    }
};

// =================================================================================
// Public API
// =================================================================================

MalwareClassifier::MalwareClassifier(const MalwareConfig& config)
    : pimpl_(std::make_unique<Impl>(config)) {}

MalwareClassifier::~MalwareClassifier() = default;
MalwareClassifier::MalwareClassifier(MalwareClassifier&&) noexcept = default;
MalwareClassifier& MalwareClassifier::operator=(MalwareClassifier&&) noexcept = default;

MalwareResult MalwareClassifier::classify(const std::vector<uint8_t>& file_bytes) {
    if (!pimpl_) throw std::runtime_error("MalwareClassifier is null.");

    // 1. Convert Binary to Image
    cv::Mat image = pimpl_->bytes_to_image(file_bytes);
    if (image.empty()) {
        return {false, "Benign", 1.0f}; // Empty file is benign
    }

    // 2. Preprocess
    preproc::ImageFrame frame;
    frame.data = image.data;
    frame.width = image.cols;
    frame.height = image.rows;
    frame.format = preproc::ImageFormat::GRAY;

    pimpl_->preproc_->process(frame, pimpl_->input_tensor);

    // 3. Inference
    pimpl_->engine_->predict({pimpl_->input_tensor}, {pimpl_->output_tensor});

    // 4. Postprocess
    auto results = pimpl_->postproc_->process(pimpl_->output_tensor);

    MalwareResult res;
    if (!results.empty() && !results[0].empty()) {
        const auto& top1 = results[0][0];
        res.family = top1.label;
        res.confidence = top1.score;

        // Simple heuristic: If not "Benign", it's malicious
        res.is_malicious = (res.family != "Benign");
    } else {
        res.is_malicious = false;
        res.family = "Unknown";
        res.confidence = 0.0f;
    }

    return res;
}

} // namespace xinfer::zoo::cybersecurity